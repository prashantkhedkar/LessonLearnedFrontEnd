import { useMemo, useState } from "react";
import { FormModel, IFormProps, ServiceFieldAttribute } from "../utils/types";
import { FieldPath, RegisterOptions } from "react-hook-form";
import { useIntl } from "react-intl";
import { ErrorLabel, InfoLabels } from "../../common/formsLabels/detailLabels";

export const TEXT = <T extends FormModel>({ divClass, containerClass, inputClass, headerClass, formControl, formHook, customHandlers, readonly }: IFormProps<T>) => {
	const [validatorSchema, setValidatorSchema] = useState<RegisterOptions<T, FieldPath<T>>>({});
	const errors = formHook.formState.errors || formHook.formState.errors[formControl["fieldKey"]];
	const fieldKey = formControl.fieldKey as FieldPath<T>;
	const [placeholder, setPlaceholder] = useState(formControl.placeholder || "");
	const intl = useIntl();

	const fieldValue = 'fieldValue' in formControl ? formControl.fieldValue : undefined;

	useMemo(() => {
		if (fieldValue !== undefined && formHook.getValues(fieldKey) === undefined) {
			formHook.setValue(fieldKey, fieldValue as any);
		}
		// Also set defaultValue if no fieldValue and field has defaultValue
		else if (fieldValue === undefined && 'defaultValue' in formControl && formControl.defaultValue !== undefined && formControl.defaultValue !== null && formControl.defaultValue !== "" && formHook.getValues(fieldKey) === undefined) {
			formHook.setValue(fieldKey, formControl.defaultValue as any);
		}
	}, [fieldValue, fieldKey, formHook, formControl]);

	useMemo(() => {
		for (const [key, value] of Object.entries(formControl)) {
			switch (key) {
				case 'isRequired':
					if (value) {
						setValidatorSchema(prevState => ({ ...prevState, required: `${intl.formatMessage({ id: "LABEL.REQUIRED" })}` }));
					}
					break;

				case 'attributes':
					if (value) {
						const attributeProperties = value as ServiceFieldAttribute;

						for (const [attrKey, attrValue] of Object.entries(attributeProperties)) {
							switch (attrKey) {
								case "maxLength":
									if (attrValue) {
										setValidatorSchema(prevState => ({
											...prevState,
											maxLength: { value: Number(attrValue), message: intl.formatMessage({ id: 'VALIDATION.MAXCHARLIMIT' }) + attrValue }
										}));
									}
									break;

								case "minLength":
									if (attrValue) {
										setValidatorSchema(prevState => ({
											...prevState,
											minLength: { value: Number(attrValue), message: intl.formatMessage({ id: 'VALIDATION.MINCHARLIMIT' }) + attrValue }
										}));
									}
									break;

								default:
									break;
							}
						}
					}
					break;

				default:
					break;
			}
		}
	}, [formControl, intl]);

	const setTextParams = (value: any) => {
		const data = (value.target as HTMLInputElement).value;

		if (value.type == 'keydown') {
			// Pre-validation from parent component
			if (customHandlers?.onBeforeChangeText) {

				const eventResult = customHandlers.onBeforeChangeText(data, formControl);

				if (typeof eventResult === "string") {
					formHook.setError(fieldKey, {
						type: 'manual',
						message: eventResult
					})
					return;
				}

				if (eventResult === false) {
					formHook.setError(fieldKey, {
						type: 'manual',
						message: `${intl.formatMessage({ id: "LABEL.REQUIRED" })}`
					})
					return;
				}
			}
		} else if (value.type == 'blur') {
			// Pre-validation from parent component
			if (customHandlers?.onBlurInputText) {
				const eventResult = customHandlers.onBlurInputText(data, formControl);

				if (typeof eventResult === "string") {
					formHook.setError(fieldKey, {
						type: 'manual',
						message: eventResult
					})
					return;
				}

				if (eventResult === false) {
					formHook.setError(fieldKey, {
						type: 'manual',
						message: `${intl.formatMessage({ id: "LABEL.REQUIRED" })}`
					})
					return;
				}
			}
		} else {
			if (data && data.length == 0) {
				setValidatorSchema(prevState => ({ ...prevState, required: `${intl.formatMessage({ id: "LABEL.REQUIRED" })}` }));

				return;
			}
		}

		formHook.clearErrors(fieldKey);

		formHook.setValue(fieldKey, data as any);

		// Post change callback
		if (customHandlers?.onChangeText) {
			customHandlers.onChangeText(value, formControl);
		}
	}

	let autoGeneratedValue: string | number | undefined = undefined;
	let hasAutoGenerated = false;
	if (formControl.attributes && !Array.isArray(formControl.attributes) && "autoGenerateFunctionValue" in formControl.attributes) {
		const val = (formControl.attributes as any).autoGenerateFunctionValue;
		if (val !== undefined && val !== null && val !== "") {
			autoGeneratedValue = val;
			hasAutoGenerated = true;
			if (formHook.getValues(fieldKey) !== val) {
				formHook.setValue(fieldKey, val as any);
			}
		}
	};

	// Only set defaultValue if fieldValue is not present
	const registerOptions: RegisterOptions<T, FieldPath<T>> = { ...validatorSchema };

	// Set default value in form if available
	if (fieldValue === undefined && 'defaultValue' in formControl && formControl.defaultValue !== undefined && formControl.defaultValue !== null && formControl.defaultValue !== "") {
		if (formHook.getValues(fieldKey) === undefined) {
			formHook.setValue(fieldKey, formControl.defaultValue as any);
		}
	}
	const inputProps: any = {
		className: 'form-control form-control-solid active input5 lbl-text-regular-2',
		type: "text",
		placeholder: intl.formatMessage({ id: placeholder }),
		...formHook.register(fieldKey, registerOptions),
		name: fieldKey,
		onBlur: (e) => setTextParams(e),
		onKeyDown: (e) => setTextParams(e),
		maxLength: !Array.isArray(formControl.attributes) && formControl.attributes?.maxLength ? Number(formControl.attributes.maxLength) : undefined,
		autoComplete: "off",
		key: fieldKey,
		id: String(formControl.fieldKey),
		readOnly: hasAutoGenerated || readonly,
		disabled: hasAutoGenerated
	};

	if (hasAutoGenerated) {
		inputProps.value = (() => {
			const v = formHook.getValues(fieldKey);

			if (typeof v === 'string' || typeof v === 'number') return v;
			if (v === undefined || v === null) return v;
			if (typeof v === 'boolean') return v ? 'Yes' : 'No';
			if (Array.isArray(v)) return v.join(', ');
			if (typeof v === 'object') return JSON.stringify(v);
			return String(v);
		})();
	};

	return (
		<div>
			<div className={containerClass}>
				<div className={headerClass}>
					<InfoLabels text={formControl["fieldLabel"]} isI18nKey={true} isRequired={(formControl["isRequired"]) as boolean} />
				</div>
				<div className={`${inputClass}`}>
					<input {...inputProps} />
					{
						errors[fieldKey] &&
						errors[fieldKey]?.message && (
							<ErrorLabel text={String(errors[fieldKey]?.message)} isI18nKey={false} />
						)
					}
				</div>
			</div>
		</div>
	);
}